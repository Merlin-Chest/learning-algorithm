# 排序算法

## 基本介绍

- 内部排序
  - 将需要处理的所有数据都加载到内部存储器中进行排序。
  - 分类
    - 插入排序
      - 直接插入排序
      - 希尔排序
    - 选择排序
      - 简单选择排序
      - 堆排序
    - 交换排序
      - 冒泡排序
      - 快速排序
    - 归并排序
    - 基数排序（桶排序）
- 外部排序

## 时间复杂度

- 方法
  - 事后统计法
  - 事前估算法

- 时间频度 T(n) ：一个算法中语句的执行次数
  - 算法话费的时间与算法中语句执行次数成正比

- 时间复杂度 O(n)
  - T(n)不同，O(n)可能相同
  - 常见的时间复杂度
    - 1、log2n、n、nlog2n、n^2^、n^3^、n^k^、2^n^、n！

- 平均时间复杂度
- 最坏时间复杂度

## 空间复杂度

该算法所消耗的存储空间 

## 冒泡排序

从前到后依次比较相邻元素的值，发现逆序这交换，使值比较大的逐渐从前移向后。

- 规则
  - 一共进行数组的大小-1次的循环
  - 每一趟排序的次数在逐渐的减少
  - 如果我们发现在某趟排序中，没有发生一次交换，可以提前结束排序（优化）

```java
public static void bubbleSort(int[] arr) {
    int temp = 0; //临时变量
    boolean flag = false; //标识变量，表示是否进行过排序
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                flag = true;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
        //优化点
        if (!flag) {
            //在一趟排序中。一次交换也没有发生，说明已经有序
            break;
        } else {
            //重置flag，进行下次判断
            flag = false;
        }
    }
}
```

## 选择排序

按指定规则选出某个元素，再依规定交换位置后达到排序的目的。

- 规则
  - 一共有n-1轮排序
  - 假定当前的数是最小数，从后面的每个数一次比较
  - 如果找到更小数，重新确定最小数，获得下标
  - 遍历完本轮数组后，进行交换
  - 之后缩减范围，继续重复过程

```java
public static void selectSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                //如果发现不是最小值，记录最小值下标
                minIndex = j;
            }
        }
        //发现min下标发生改变
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
```

## 插入排序

对欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的

```java
public static void insertSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int insertVal = arr[i]; //存储要插入的值
        int index = i - 1; //待插入的数的前一个数的下标，该数之前的数组已经有序
        while (index >= 0 && arr[index] > insertVal) {
            //将该位置的数后移
            arr[index + 1] = arr[index];
            //继续向前查找
            index--;
        }
        //判断是否需要插入
        if (index + 1 != i) {
            //当退出循环时，说明插入位置已经找到
            arr[index + 1] = insertVal;
        }
    }
}
```

存在问题：当需要插入的数是比较小的数时，后移的次数明显增多，对效率有影响

## 希尔排序*

